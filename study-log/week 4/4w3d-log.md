### 공유 사항
- 오늘 루이지 코드 리뷰
### 공부 내용
- json parser lesson 01 피드백
  - new Array 보다는 [] 표현법이 많이 쓰입니다. new Array의 문제를 찾아보는 것도 좋아요
    - 객체 생성자 함수 new Object()는 인자를 받을 수 있는데, 인자의 타입에 따라 동작을 다르게 합니다. 때문에 런타임에 생성되는 동적인 값이 생성자에 인자로 전달될 경우 예기치 않은 결과가 반환 될 수 있습니다.
    - 배열 생성자 함수 new Array()도 비슷한 문제로 인자를 받을 수 있는데 생성자에 숫자 하나를 전달할 경우 이 값은 배열의 첫 번째 원소가 되는 것이 아니고 배열의 길이를 지정합니다. JavaScript에서의 배열은 Java나 C와 같은 진짜 배열이 아니기 때문에 대부분 이런 식으로 배열의 길이를 지정해 줄 필요가 없습니다. 이것도 의외의 동작 방식이지만, 인자에 정수가 아닌 소수를 가지는 수를 전달할 경우에는 배열의 길이로 유효한 값이 아니기 때문에 에러가 발생 하기까지 합니다.
- 추가 공부
  - 3.4 비트연산자
  - JavaScript에는 Java와 같은 비트연산자 들이 있습니다. Java에서 비트 연산자는 정수에 대해서 동작합니다. 그런데 JavaScript에는 정수형은 없고 단지 부동 소수점 숫자형 만이 존재합니다. 그래서 JavaScript의 비트 연산자는 대상이 되는 숫자를 일단 정수형으로 변환한 다음 비트 연산을 수행하고 다시 원래의 타입으로 되돌립니다. 대부분의 언어에서 비트 연산자는 하드웨어에 친근하고 속도도 매우 빠르지만, JavaScript의 비트 연산자는 하드웨어와 전혀 친근하지 않고 속도가 느립니다.
- 루이지 코드 리뷰
  - 프로토타입은 한 번에 만드는 게 좋다. 생성자는 만들어지는 자체에만 집중하고 프로토타입 메서드로 init()를 넣어서 이니셜라이징을 따로 해주는 게 좋다.
  - 인자를 줄 때 길다 싶으면 객체로 주는 게 좋다.
  - 객체 내의 코드는 밖에서 어떻게 보여질까가 중요하다. 다른 개발자들이 쓸 때 처음 이 객체가 어떻게 읽혀질 것인가.
    ~~~
    var myrunner = new parser.runner();
    myrunner.init({
      value : 0,
      name : 'luigi',
      afterFn : codesquad.objshow()
    })
    ~~~ 
  - 상속
    - 프로토타입을 같이 쓴다. 재사용하는 것. 중복을 없애는 것.
    - 부모에 재사용가능한 메서드를 몰아둔다. 초기화, 에러처리 등.
    - 객체를 복제하는 것도 가능하다. apply와 call을 잘 쓰면. apply는 실행 영역을 지정해주는 것. 잘 쓰면 상속을 흉내낼 수 있다. 하지만 사용하는 경우는 많지 않다.
    ~~~
    a.call(methods, null);
    ~~~
    - 자식이 가벼워질수록 재사용성이 높아진다. 새로운 것을 추가했을 때 추가하기 쉽고 수정되었을 때 수정하기 쉽고.
    - 대신 응집도를 잃는다. 응집도를 유지하려면 옵션을 받는 게 좋을 수 있다. 옵션을 받는 메소드를 만들어서 몰아둔다거나.
  - 버전 업그레이드
    - 1.0.0 => 2.0.0
      - 하위호환 안됨
    - 