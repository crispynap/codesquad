# 2주 2일차 학습 내용 정리
### 공유 사항
- 학습일지 잘 작성했으면. 쓰고서 링크를 슬랙에 공유를.
- PR 날릴 때 코멘트를 달 수 있음. 레슨의 어디까지 구현한 것인지 코멘트를.
- 가급적 설계 리뷰를 받을 것. 
- 본인 피씨에서 개발할 때도 브랜치 나누고 합치는 과정을 겪어볼 것. 동일한 소스에 여러 버전의 파일을 만들지 말 것.
- git 워크플로우를 검색하면 git을 기반으로 서비스를 만들 때 어떻게 하는지 참고해볼 수 있다.
### 공부 계획
- 할일 관리 앱 설계 / 제작
- Tim 코드 리뷰 진행
- 즉시실행함수, 프로토타입, this, bind 공부
### 공부 내용
- tim 코드 리뷰 전 메모
  - 그냥 add를 하면 undefined가 추가된다/update$id 만 하면 task가 사라진다
  - 커맨드 처리 부분에서 switch/case와 if/else문의 차이가 어떤 게 있을지 궁금
  - user.addTask(title).showAllTask(); 에서 메소드 체이닝 방식으로 구현했다가 showAllTask를 addTask 안으로 넣은 이유가 궁금
  - 현재 상태를 왜 상수로 정의해두고 숫자로 썼는지?
- tim 코드 리뷰
  - app.js 7~26: 전역에서 즉시 실행식 함수로 메인 루틴을 선언. 전역 변수를 없앨 수 있기 때문. 이 방법을 많이 쓴다.
  - switch/case와 if/else문의 차이 : 거진 취향 차이. 좀 많으면 switch case가 나아보이긴 하지만. if는 비교하는 데 쓰는 게 낫고. 참고로 3항 연산자는 간단한 상황에서 쓰는 게 좋다. 복잡한 상황의 연산은 가능하지만 가독성이 떨어져서. 코드가 줄바꿈을 해야하거나 가로 스크롤을 해야하면 안 좋은 코드.
  - app.js 20~21: 배열 순서로 지정하는 것 좋지 않다. 소프트웨어가 변경될 때 버그가 생길 가능성. 
  - user.js 19~21: 디스트럭쳐링 참고. 그러나 줄바꿈은 않는 게 좋다. ES6 문법.
  - user.js 26: addTask에서 task를 new로 생성했다. 생성자 함수에서 new task를 부르는 것도 가능하겠다. 단점도 있다. 쓰지도 않는 인스턴스를 미리 만들어두는 것. 장점은 user가 task에 의존하고 있다는 것을 알려주는 것이다. 크롱은 후자를 선호. 코드가 커지고 의존성이 많아질 경우, 의존관계가 분산되기 쉬운데 그것을 일목요연하게 보여주는 역할.
  - user.js 27: addTask()가 new Task()에 의존하고 있기도 하다. addTask(tasks) 이런 방식으로 의존관계를 인자를 쓰는 방식으로 나눌 수 있다. 인자는 많이 쓰는 게 좋고, 그만큼 범용성은 올라간다. 인자는 즉 옵션이므로. 함수가 가능한 순수해지도록 만드는 게 좋다.
  - user.js 48: string 앞에 +를 붙이면 숫자로 변환해줌.
  - user.js 49: filter()와 map()을 쓸 필요가 있는가? for 문이 더 적절하다. 배열 조작 메소드로 연결되어 있으니까 배열을 다루는 함수처럼 보인다. 
  - user.js 53: shortTask 찾는 것은 서브 함수로 빼는 게 좋겠다.
  - user.js 53: shortTask length가 0인지 보지 말고 shortTask를 생성할 때 null로 초기화해서 null과 비교하는 게 더 간편해보이겠다.
- 크롱 피드백
  - 객체 리터럴이 아니라 new 연산자와 프로토타입을 썼는데, 객체를 효율적으로 만드는 방법이다.
  - 폴리필을 직접 만들어보는 것도 좋다.
  - 프로토타입/this/bind 정도는 설명할 수 있어야 한다.
  - 즉시실행함수를 썼다. 즉시실행함수를 찾아보라. 직접 테스트를 해보면 좋다. 괄호를 여러 개 넣고 분리도 해보고. 보통 어떤 때 사용하냐면, 클릭 로그를 만드는 조각 도구 / 페이스북 로그인을 위한 스크립트 코드 등을 임포트해올 때 충돌이 날 수 있다. 그때 즉시 실행 함수를 쓰고 함수 스코프를 만들어서 독립적으로 동작되도록 만들곤 한다.
- 발표에 대한 피드백
  - 코드를 나열식이 아니라 전달하고 싶은 핵심 내용을 강조해서 전달하면 좋겠다.